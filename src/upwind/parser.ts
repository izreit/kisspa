/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* ---
* export type Mod = {
*    modKey: string;
*    target: { name: string, rel: string | null } | null;
*    begin: number;
*    end: number;
* };
* export type Decl = {
*   modifiers: Mod[];
*   name: string[];
*   value: string[] | null;
*   begin: number;
*   end: number;
* };
* ---
* DECLS
*  := _ beginpos=@ head=DECL tail={__ d=DECL}* endpos=@ _
*    .val = Decl[] { return [...this.head.val, ...this.tail.map(t => t.d.val).flat()]; }
*  | beginpos=@ _ endpos=@ $
*    .val = Decl[] { return []; }
* DECL
*  := mod=MOD '/{' ds=DECLS '}' 
*    .val = Decl[] { return this.ds.val.map(d => ({ ...d, modifiers: d.modifiers.concat(this.mod.val) })); }
*  | mod=MOD '/' decl=DECL
*    .val = Decl[] { return this.decl.val.map(d => ({ ...d, modifiers: d.modifiers.concat(this.mod.val) })); }
*  | beginpos=@ name=NAME v={':' c=VAL}? endpos=@
*    .val = Decl[] {
*      const begin = this.beginpos.overallPos;
*      const end = this.endpos.overallPos;
*      return [{ modifiers: [], name: this.name.val, value: this.v?.c.val ?? null, begin, end }];
*    }
* MOD
*  := beginpos=@ v=':*[^/_:\s]+' target={'_' name='[^/:\s~\+]+' rel='[~\+]'?}? endpos=@
*    .val = Mod {
*      const begin = this.beginpos.overallPos;
*      const end = this.endpos.overallPos;
*      const tgt = this.target;
*      const target = tgt ? { name: tgt.name, rel: tgt.rel ?? null } : null;
*      return { modKey: this.v, target, begin, end };
*    }
* NAME
*  := head=FRAG tail={'-' f=FRAG}*
*    .val = string[] { return [this.head, ...this.tail.map(t => t.f)]; }
* FRAG := '[^-\s:\.]+'
* VAL
*  := '_*' head={NONUS | QUOTED} tail={'_+' v={NONUS | QUOTED}}* '_*'
*    .val = string[] { return [this.head.val, ...this.tail.map(t => t.v.val)]; }
* NONUS
*  := v='([^\s_}]|\\_)+'
*    .val = string { return this.v.replace(/\\_/g, "_"); }
* QUOTED
*   := '\'' v='([^\']|\\\')*' '\''
*    .val = string { return this.v.replace(/\\\u0027/g, "'"); }
* __ := '[ \t\n\r]+'
* _ := '[ \t\n\r]*'
*/

export type Mod = {
   modKey: string;
   target: { name: string, rel: string | null } | null;
   begin: number;
   end: number;
};
export type Decl = {
  modifiers: Mod[];
  name: string[];
  value: string[] | null;
  begin: number;
  end: number;
};

type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
export interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    DECLS_1 = "DECLS_1",
    DECLS_2 = "DECLS_2",
    DECLS_$0 = "DECLS_$0",
    DECL_1 = "DECL_1",
    DECL_2 = "DECL_2",
    DECL_3 = "DECL_3",
    DECL_$0 = "DECL_$0",
    MOD = "MOD",
    MOD_$0 = "MOD_$0",
    NAME = "NAME",
    NAME_$0 = "NAME_$0",
    FRAG = "FRAG",
    VAL = "VAL",
    VAL_$0_1 = "VAL_$0_1",
    VAL_$0_2 = "VAL_$0_2",
    VAL_$1 = "VAL_$1",
    VAL_$1_$0_1 = "VAL_$1_$0_1",
    VAL_$1_$0_2 = "VAL_$1_$0_2",
    NONUS = "NONUS",
    QUOTED = "QUOTED",
    __ = "__",
    _ = "_",
    $EOF = "$EOF",
}
export type DECLS = DECLS_1 | DECLS_2;
export class DECLS_1 {
    public kind: ASTKinds.DECLS_1 = ASTKinds.DECLS_1;
    public beginpos: PosInfo;
    public head: DECL;
    public tail: DECLS_$0[];
    public endpos: PosInfo;
    public val: Decl[];
    constructor(beginpos: PosInfo, head: DECL, tail: DECLS_$0[], endpos: PosInfo){
        this.beginpos = beginpos;
        this.head = head;
        this.tail = tail;
        this.endpos = endpos;
        this.val = ((): Decl[] => {
        return [...this.head.val, ...this.tail.map(t => t.d.val).flat()];
        })();
    }
}
export class DECLS_2 {
    public kind: ASTKinds.DECLS_2 = ASTKinds.DECLS_2;
    public beginpos: PosInfo;
    public endpos: PosInfo;
    public val: Decl[];
    constructor(beginpos: PosInfo, endpos: PosInfo){
        this.beginpos = beginpos;
        this.endpos = endpos;
        this.val = ((): Decl[] => {
        return [];
        })();
    }
}
export interface DECLS_$0 {
    kind: ASTKinds.DECLS_$0;
    d: DECL;
}
export type DECL = DECL_1 | DECL_2 | DECL_3;
export class DECL_1 {
    public kind: ASTKinds.DECL_1 = ASTKinds.DECL_1;
    public mod: MOD;
    public ds: DECLS;
    public val: Decl[];
    constructor(mod: MOD, ds: DECLS){
        this.mod = mod;
        this.ds = ds;
        this.val = ((): Decl[] => {
        return this.ds.val.map(d => ({ ...d, modifiers: d.modifiers.concat(this.mod.val) }));
        })();
    }
}
export class DECL_2 {
    public kind: ASTKinds.DECL_2 = ASTKinds.DECL_2;
    public mod: MOD;
    public decl: DECL;
    public val: Decl[];
    constructor(mod: MOD, decl: DECL){
        this.mod = mod;
        this.decl = decl;
        this.val = ((): Decl[] => {
        return this.decl.val.map(d => ({ ...d, modifiers: d.modifiers.concat(this.mod.val) }));
        })();
    }
}
export class DECL_3 {
    public kind: ASTKinds.DECL_3 = ASTKinds.DECL_3;
    public beginpos: PosInfo;
    public name: NAME;
    public v: Nullable<DECL_$0>;
    public endpos: PosInfo;
    public val: Decl[];
    constructor(beginpos: PosInfo, name: NAME, v: Nullable<DECL_$0>, endpos: PosInfo){
        this.beginpos = beginpos;
        this.name = name;
        this.v = v;
        this.endpos = endpos;
        this.val = ((): Decl[] => {
        const begin = this.beginpos.overallPos;
     const end = this.endpos.overallPos;
     return [{ modifiers: [], name: this.name.val, value: this.v?.c.val ?? null, begin, end }];
        })();
    }
}
export interface DECL_$0 {
    kind: ASTKinds.DECL_$0;
    c: VAL;
}
export class MOD {
    public kind: ASTKinds.MOD = ASTKinds.MOD;
    public beginpos: PosInfo;
    public v: string;
    public target: Nullable<MOD_$0>;
    public endpos: PosInfo;
    public val: Mod;
    constructor(beginpos: PosInfo, v: string, target: Nullable<MOD_$0>, endpos: PosInfo){
        this.beginpos = beginpos;
        this.v = v;
        this.target = target;
        this.endpos = endpos;
        this.val = ((): Mod => {
        const begin = this.beginpos.overallPos;
     const end = this.endpos.overallPos;
     const tgt = this.target;
     const target = tgt ? { name: tgt.name, rel: tgt.rel ?? null } : null;
     return { modKey: this.v, target, begin, end };
        })();
    }
}
export interface MOD_$0 {
    kind: ASTKinds.MOD_$0;
    name: string;
    rel: Nullable<string>;
}
export class NAME {
    public kind: ASTKinds.NAME = ASTKinds.NAME;
    public head: FRAG;
    public tail: NAME_$0[];
    public val: string[];
    constructor(head: FRAG, tail: NAME_$0[]){
        this.head = head;
        this.tail = tail;
        this.val = ((): string[] => {
        return [this.head, ...this.tail.map(t => t.f)];
        })();
    }
}
export interface NAME_$0 {
    kind: ASTKinds.NAME_$0;
    f: FRAG;
}
export type FRAG = string;
export class VAL {
    public kind: ASTKinds.VAL = ASTKinds.VAL;
    public head: VAL_$0;
    public tail: VAL_$1[];
    public val: string[];
    constructor(head: VAL_$0, tail: VAL_$1[]){
        this.head = head;
        this.tail = tail;
        this.val = ((): string[] => {
        return [this.head.val, ...this.tail.map(t => t.v.val)];
        })();
    }
}
export type VAL_$0 = VAL_$0_1 | VAL_$0_2;
export type VAL_$0_1 = NONUS;
export type VAL_$0_2 = QUOTED;
export interface VAL_$1 {
    kind: ASTKinds.VAL_$1;
    v: VAL_$1_$0;
}
export type VAL_$1_$0 = VAL_$1_$0_1 | VAL_$1_$0_2;
export type VAL_$1_$0_1 = NONUS;
export type VAL_$1_$0_2 = QUOTED;
export class NONUS {
    public kind: ASTKinds.NONUS = ASTKinds.NONUS;
    public v: string;
    public val: string;
    constructor(v: string){
        this.v = v;
        this.val = ((): string => {
        return this.v.replace(/\\_/g, "_");
        })();
    }
}
export class QUOTED {
    public kind: ASTKinds.QUOTED = ASTKinds.QUOTED;
    public v: string;
    public val: string;
    constructor(v: string){
        this.v = v;
        this.val = ((): string => {
        return this.v.replace(/\\\u0027/g, "'");
        })();
    }
}
export type __ = string;
export type _ = string;
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
        this.$scope$DECLS$memo.clear();
        this.$scope$DECLS_$0$memo.clear();
        this.$scope$DECL$memo.clear();
        this.$scope$DECL_$0$memo.clear();
        this.$scope$MOD$memo.clear();
        this.$scope$MOD_$0$memo.clear();
        this.$scope$NAME$memo.clear();
        this.$scope$NAME_$0$memo.clear();
        this.$scope$FRAG$memo.clear();
        this.$scope$VAL$memo.clear();
        this.$scope$VAL_$0$memo.clear();
        this.$scope$VAL_$1$memo.clear();
        this.$scope$VAL_$1_$0$memo.clear();
        this.$scope$NONUS$memo.clear();
        this.$scope$QUOTED$memo.clear();
        this.$scope$__$memo.clear();
        this.$scope$_$memo.clear();
    }
    protected $scope$DECLS$memo: Map<number, [Nullable<DECLS>, PosInfo]> = new Map();
    protected $scope$DECLS_$0$memo: Map<number, [Nullable<DECLS_$0>, PosInfo]> = new Map();
    protected $scope$DECL$memo: Map<number, [Nullable<DECL>, PosInfo]> = new Map();
    protected $scope$DECL_$0$memo: Map<number, [Nullable<DECL_$0>, PosInfo]> = new Map();
    protected $scope$MOD$memo: Map<number, [Nullable<MOD>, PosInfo]> = new Map();
    protected $scope$MOD_$0$memo: Map<number, [Nullable<MOD_$0>, PosInfo]> = new Map();
    protected $scope$NAME$memo: Map<number, [Nullable<NAME>, PosInfo]> = new Map();
    protected $scope$NAME_$0$memo: Map<number, [Nullable<NAME_$0>, PosInfo]> = new Map();
    protected $scope$FRAG$memo: Map<number, [Nullable<FRAG>, PosInfo]> = new Map();
    protected $scope$VAL$memo: Map<number, [Nullable<VAL>, PosInfo]> = new Map();
    protected $scope$VAL_$0$memo: Map<number, [Nullable<VAL_$0>, PosInfo]> = new Map();
    protected $scope$VAL_$1$memo: Map<number, [Nullable<VAL_$1>, PosInfo]> = new Map();
    protected $scope$VAL_$1_$0$memo: Map<number, [Nullable<VAL_$1_$0>, PosInfo]> = new Map();
    protected $scope$NONUS$memo: Map<number, [Nullable<NONUS>, PosInfo]> = new Map();
    protected $scope$QUOTED$memo: Map<number, [Nullable<QUOTED>, PosInfo]> = new Map();
    protected $scope$__$memo: Map<number, [Nullable<__>, PosInfo]> = new Map();
    protected $scope$_$memo: Map<number, [Nullable<_>, PosInfo]> = new Map();
    public matchDECLS($$dpth: number, $$cr?: ErrorTracker): Nullable<DECLS> {
        return this.memoise(
            () => {
                return this.choice<DECLS>([
                    () => this.matchDECLS_1($$dpth + 1, $$cr),
                    () => this.matchDECLS_2($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$DECLS$memo,
        );
    }
    public matchDECLS_1($$dpth: number, $$cr?: ErrorTracker): Nullable<DECLS_1> {
        return this.run<DECLS_1>($$dpth,
            () => {
                let $scope$beginpos: Nullable<PosInfo>;
                let $scope$head: Nullable<DECL>;
                let $scope$tail: Nullable<DECLS_$0[]>;
                let $scope$endpos: Nullable<PosInfo>;
                let $$res: Nullable<DECLS_1> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$beginpos = this.mark()) !== null
                    && ($scope$head = this.matchDECL($$dpth + 1, $$cr)) !== null
                    && ($scope$tail = this.loop<DECLS_$0>(() => this.matchDECLS_$0($$dpth + 1, $$cr), 0, -1)) !== null
                    && ($scope$endpos = this.mark()) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = new DECLS_1($scope$beginpos, $scope$head, $scope$tail, $scope$endpos);
                }
                return $$res;
            });
    }
    public matchDECLS_2($$dpth: number, $$cr?: ErrorTracker): Nullable<DECLS_2> {
        return this.run<DECLS_2>($$dpth,
            () => {
                let $scope$beginpos: Nullable<PosInfo>;
                let $scope$endpos: Nullable<PosInfo>;
                let $$res: Nullable<DECLS_2> = null;
                if (true
                    && ($scope$beginpos = this.mark()) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$endpos = this.mark()) !== null
                    && this.match$EOF($$cr) !== null
                ) {
                    $$res = new DECLS_2($scope$beginpos, $scope$endpos);
                }
                return $$res;
            });
    }
    public matchDECLS_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<DECLS_$0> {
        return this.memoise(
            () => {
                return this.run<DECLS_$0>($$dpth,
                    () => {
                        let $scope$d: Nullable<DECL>;
                        let $$res: Nullable<DECLS_$0> = null;
                        if (true
                            && this.match__($$dpth + 1, $$cr) !== null
                            && ($scope$d = this.matchDECL($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.DECLS_$0, d: $scope$d};
                        }
                        return $$res;
                    });
            },
            this.$scope$DECLS_$0$memo,
        );
    }
    public matchDECL($$dpth: number, $$cr?: ErrorTracker): Nullable<DECL> {
        return this.memoise(
            () => {
                return this.choice<DECL>([
                    () => this.matchDECL_1($$dpth + 1, $$cr),
                    () => this.matchDECL_2($$dpth + 1, $$cr),
                    () => this.matchDECL_3($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$DECL$memo,
        );
    }
    public matchDECL_1($$dpth: number, $$cr?: ErrorTracker): Nullable<DECL_1> {
        return this.run<DECL_1>($$dpth,
            () => {
                let $scope$mod: Nullable<MOD>;
                let $scope$ds: Nullable<DECLS>;
                let $$res: Nullable<DECL_1> = null;
                if (true
                    && ($scope$mod = this.matchMOD($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:/{)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$ds = this.matchDECLS($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:})`, "", $$dpth + 1, $$cr) !== null
                ) {
                    $$res = new DECL_1($scope$mod, $scope$ds);
                }
                return $$res;
            });
    }
    public matchDECL_2($$dpth: number, $$cr?: ErrorTracker): Nullable<DECL_2> {
        return this.run<DECL_2>($$dpth,
            () => {
                let $scope$mod: Nullable<MOD>;
                let $scope$decl: Nullable<DECL>;
                let $$res: Nullable<DECL_2> = null;
                if (true
                    && ($scope$mod = this.matchMOD($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:/)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$decl = this.matchDECL($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new DECL_2($scope$mod, $scope$decl);
                }
                return $$res;
            });
    }
    public matchDECL_3($$dpth: number, $$cr?: ErrorTracker): Nullable<DECL_3> {
        return this.run<DECL_3>($$dpth,
            () => {
                let $scope$beginpos: Nullable<PosInfo>;
                let $scope$name: Nullable<NAME>;
                let $scope$v: Nullable<Nullable<DECL_$0>>;
                let $scope$endpos: Nullable<PosInfo>;
                let $$res: Nullable<DECL_3> = null;
                if (true
                    && ($scope$beginpos = this.mark()) !== null
                    && ($scope$name = this.matchNAME($$dpth + 1, $$cr)) !== null
                    && (($scope$v = this.matchDECL_$0($$dpth + 1, $$cr)) || true)
                    && ($scope$endpos = this.mark()) !== null
                ) {
                    $$res = new DECL_3($scope$beginpos, $scope$name, $scope$v, $scope$endpos);
                }
                return $$res;
            });
    }
    public matchDECL_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<DECL_$0> {
        return this.memoise(
            () => {
                return this.run<DECL_$0>($$dpth,
                    () => {
                        let $scope$c: Nullable<VAL>;
                        let $$res: Nullable<DECL_$0> = null;
                        if (true
                            && this.regexAccept(String.raw`(?::)`, "", $$dpth + 1, $$cr) !== null
                            && ($scope$c = this.matchVAL($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.DECL_$0, c: $scope$c};
                        }
                        return $$res;
                    });
            },
            this.$scope$DECL_$0$memo,
        );
    }
    public matchMOD($$dpth: number, $$cr?: ErrorTracker): Nullable<MOD> {
        return this.memoise(
            () => {
                return this.run<MOD>($$dpth,
                    () => {
                        let $scope$beginpos: Nullable<PosInfo>;
                        let $scope$v: Nullable<string>;
                        let $scope$target: Nullable<Nullable<MOD_$0>>;
                        let $scope$endpos: Nullable<PosInfo>;
                        let $$res: Nullable<MOD> = null;
                        if (true
                            && ($scope$beginpos = this.mark()) !== null
                            && ($scope$v = this.regexAccept(String.raw`(?::*[^/_:\s]+)`, "", $$dpth + 1, $$cr)) !== null
                            && (($scope$target = this.matchMOD_$0($$dpth + 1, $$cr)) || true)
                            && ($scope$endpos = this.mark()) !== null
                        ) {
                            $$res = new MOD($scope$beginpos, $scope$v, $scope$target, $scope$endpos);
                        }
                        return $$res;
                    });
            },
            this.$scope$MOD$memo,
        );
    }
    public matchMOD_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<MOD_$0> {
        return this.memoise(
            () => {
                return this.run<MOD_$0>($$dpth,
                    () => {
                        let $scope$name: Nullable<string>;
                        let $scope$rel: Nullable<Nullable<string>>;
                        let $$res: Nullable<MOD_$0> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:_)`, "", $$dpth + 1, $$cr) !== null
                            && ($scope$name = this.regexAccept(String.raw`(?:[^/:\s~\+]+)`, "", $$dpth + 1, $$cr)) !== null
                            && (($scope$rel = this.regexAccept(String.raw`(?:[~\+])`, "", $$dpth + 1, $$cr)) || true)
                        ) {
                            $$res = {kind: ASTKinds.MOD_$0, name: $scope$name, rel: $scope$rel};
                        }
                        return $$res;
                    });
            },
            this.$scope$MOD_$0$memo,
        );
    }
    public matchNAME($$dpth: number, $$cr?: ErrorTracker): Nullable<NAME> {
        return this.memoise(
            () => {
                return this.run<NAME>($$dpth,
                    () => {
                        let $scope$head: Nullable<FRAG>;
                        let $scope$tail: Nullable<NAME_$0[]>;
                        let $$res: Nullable<NAME> = null;
                        if (true
                            && ($scope$head = this.matchFRAG($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<NAME_$0>(() => this.matchNAME_$0($$dpth + 1, $$cr), 0, -1)) !== null
                        ) {
                            $$res = new NAME($scope$head, $scope$tail);
                        }
                        return $$res;
                    });
            },
            this.$scope$NAME$memo,
        );
    }
    public matchNAME_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<NAME_$0> {
        return this.memoise(
            () => {
                return this.run<NAME_$0>($$dpth,
                    () => {
                        let $scope$f: Nullable<FRAG>;
                        let $$res: Nullable<NAME_$0> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:-)`, "", $$dpth + 1, $$cr) !== null
                            && ($scope$f = this.matchFRAG($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.NAME_$0, f: $scope$f};
                        }
                        return $$res;
                    });
            },
            this.$scope$NAME_$0$memo,
        );
    }
    public matchFRAG($$dpth: number, $$cr?: ErrorTracker): Nullable<FRAG> {
        return this.memoise(
            () => {
                return this.regexAccept(String.raw`(?:[^-\s:\.]+)`, "", $$dpth + 1, $$cr);
            },
            this.$scope$FRAG$memo,
        );
    }
    public matchVAL($$dpth: number, $$cr?: ErrorTracker): Nullable<VAL> {
        return this.memoise(
            () => {
                return this.run<VAL>($$dpth,
                    () => {
                        let $scope$head: Nullable<VAL_$0>;
                        let $scope$tail: Nullable<VAL_$1[]>;
                        let $$res: Nullable<VAL> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:_*)`, "", $$dpth + 1, $$cr) !== null
                            && ($scope$head = this.matchVAL_$0($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<VAL_$1>(() => this.matchVAL_$1($$dpth + 1, $$cr), 0, -1)) !== null
                            && this.regexAccept(String.raw`(?:_*)`, "", $$dpth + 1, $$cr) !== null
                        ) {
                            $$res = new VAL($scope$head, $scope$tail);
                        }
                        return $$res;
                    });
            },
            this.$scope$VAL$memo,
        );
    }
    public matchVAL_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<VAL_$0> {
        return this.memoise(
            () => {
                return this.choice<VAL_$0>([
                    () => this.matchVAL_$0_1($$dpth + 1, $$cr),
                    () => this.matchVAL_$0_2($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$VAL_$0$memo,
        );
    }
    public matchVAL_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<VAL_$0_1> {
        return this.matchNONUS($$dpth + 1, $$cr);
    }
    public matchVAL_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<VAL_$0_2> {
        return this.matchQUOTED($$dpth + 1, $$cr);
    }
    public matchVAL_$1($$dpth: number, $$cr?: ErrorTracker): Nullable<VAL_$1> {
        return this.memoise(
            () => {
                return this.run<VAL_$1>($$dpth,
                    () => {
                        let $scope$v: Nullable<VAL_$1_$0>;
                        let $$res: Nullable<VAL_$1> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:_+)`, "", $$dpth + 1, $$cr) !== null
                            && ($scope$v = this.matchVAL_$1_$0($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.VAL_$1, v: $scope$v};
                        }
                        return $$res;
                    });
            },
            this.$scope$VAL_$1$memo,
        );
    }
    public matchVAL_$1_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<VAL_$1_$0> {
        return this.memoise(
            () => {
                return this.choice<VAL_$1_$0>([
                    () => this.matchVAL_$1_$0_1($$dpth + 1, $$cr),
                    () => this.matchVAL_$1_$0_2($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$VAL_$1_$0$memo,
        );
    }
    public matchVAL_$1_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<VAL_$1_$0_1> {
        return this.matchNONUS($$dpth + 1, $$cr);
    }
    public matchVAL_$1_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<VAL_$1_$0_2> {
        return this.matchQUOTED($$dpth + 1, $$cr);
    }
    public matchNONUS($$dpth: number, $$cr?: ErrorTracker): Nullable<NONUS> {
        return this.memoise(
            () => {
                return this.run<NONUS>($$dpth,
                    () => {
                        let $scope$v: Nullable<string>;
                        let $$res: Nullable<NONUS> = null;
                        if (true
                            && ($scope$v = this.regexAccept(String.raw`(?:([^\s_}]|\\_)+)`, "", $$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = new NONUS($scope$v);
                        }
                        return $$res;
                    });
            },
            this.$scope$NONUS$memo,
        );
    }
    public matchQUOTED($$dpth: number, $$cr?: ErrorTracker): Nullable<QUOTED> {
        return this.memoise(
            () => {
                return this.run<QUOTED>($$dpth,
                    () => {
                        let $scope$v: Nullable<string>;
                        let $$res: Nullable<QUOTED> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:\')`, "", $$dpth + 1, $$cr) !== null
                            && ($scope$v = this.regexAccept(String.raw`(?:([^\']|\\\')*)`, "", $$dpth + 1, $$cr)) !== null
                            && this.regexAccept(String.raw`(?:\')`, "", $$dpth + 1, $$cr) !== null
                        ) {
                            $$res = new QUOTED($scope$v);
                        }
                        return $$res;
                    });
            },
            this.$scope$QUOTED$memo,
        );
    }
    public match__($$dpth: number, $$cr?: ErrorTracker): Nullable<__> {
        return this.memoise(
            () => {
                return this.regexAccept(String.raw`(?:[ \t\n\r]+)`, "", $$dpth + 1, $$cr);
            },
            this.$scope$__$memo,
        );
    }
    public match_($$dpth: number, $$cr?: ErrorTracker): Nullable<_> {
        return this.memoise(
            () => {
                return this.regexAccept(String.raw`(?:[ \t\n\r]*)`, "", $$dpth + 1, $$cr);
            },
            this.$scope$_$memo,
        );
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchDECLS(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchDECLS(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchDECLS(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    // @ts-ignore: loopPlus may not be called
    private loopPlus<T>(func: $$RuleType<T>): Nullable<[T, ...T[]]> {
        return this.loop(func, 1, -1) as Nullable<[T, ...T[]]>;
    }
    private loop<T>(func: $$RuleType<T>, lb: number, ub: number): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        while (ub === -1 || res.length < ub) {
            const preMrk = this.mark();
            const t = func();
            if (t === null || this.pos.overallPos === preMrk.overallPos) {
                break;
            }
            res.push(t);
        }
        if (res.length >= lb) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    // @ts-ignore: choice may not be called
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, mods: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y" + mods);
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    // @ts-ignore: noConsume may not be called
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    // @ts-ignore: negate may not be called
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    // @ts-ignore: Memoise may not be used
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {
        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;
        if(et)
            et.record(this.mark(), res, { kind: "EOF", negated: this.negating });
        return res;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<DECLS>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}