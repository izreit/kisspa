/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* ---
* export type Decl = {
*   contexts: string[];
*   name: string[];
*   value: string[];
*   begin: number;
*   end: number;
* };
* ---
* DECLS
*  := _ beginpos=@ head=DECL tail={__ d=DECL}* endpos=@ _ $
*     .val = Decl[] { return [...this.head.val, ...this.tail.map(t => t.d.val).flat()]; }
*  | beginpos=@ _ endpos=@ $
*     .val = Decl[] { return []; }
* DECL
*  := beginpos=@ name=NAME ':' v=VALUE endpos=@
*     .val = Decl[] {
*       const begin = this.beginpos.overallPos;
*       const end = this.endpos.overallPos;
*       return [{ contexts: [], name: this.name.val, value: this.v.val, begin, end }];
*     }
*  | name=NAME '.' decl=DECL
*     .val = Decl[] { return this.decl.val.map(d => ({ ...d, contexts: d.contexts.concat(this.name.val) })); }
*  | name=NAME '.\(' ds=DECLS '\)' 
*     .val = Decl[] { return this.ds.val.map(d => ({ ...d, contexts: d.contexts.concat(this.name.val) })); }
* NAME
*  := head=FRAG tail={'-' f=FRAG}*
*     .val = string[] { return [this.head, ...this.tail.map(t => t.f)]; }
* FRAG := '[^-\s:\.]+'
* VALUE := UNDERSCORE_SEPARATED
* UNDERSCORE_SEPARATED
*  := '_*' head={NONUNDERSCORE | QUOTED} tail={'_+' v={NONUNDERSCORE | QUOTED}}* '_*'
*     .val = string[] { return [this.head.val, ...this.tail.map(t => t.v.val)]; }
* NONUNDERSCORE
*  := v='([^\s_]|\\_)+'
*     .val = string { return this.v.replace(/\\_/g, "_"); }
* QUOTED
*   := '\'' v='([^\']|\\\')*' '\''
*      .val = string { return this.v.replace(/\\\u0027/g, "'"); }
* __ := '[ \t\n\r]+'
* _ := '[ \t\n\r]*'
*/

export type Decl = {
  contexts: string[];
  name: string[];
  value: string[];
  begin: number;
  end: number;
};

type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
export interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    DECLS_1 = "DECLS_1",
    DECLS_2 = "DECLS_2",
    DECLS_$0 = "DECLS_$0",
    DECL_1 = "DECL_1",
    DECL_2 = "DECL_2",
    DECL_3 = "DECL_3",
    NAME = "NAME",
    NAME_$0 = "NAME_$0",
    FRAG = "FRAG",
    VALUE = "VALUE",
    UNDERSCORE_SEPARATED = "UNDERSCORE_SEPARATED",
    UNDERSCORE_SEPARATED_$0_1 = "UNDERSCORE_SEPARATED_$0_1",
    UNDERSCORE_SEPARATED_$0_2 = "UNDERSCORE_SEPARATED_$0_2",
    UNDERSCORE_SEPARATED_$1 = "UNDERSCORE_SEPARATED_$1",
    UNDERSCORE_SEPARATED_$1_$0_1 = "UNDERSCORE_SEPARATED_$1_$0_1",
    UNDERSCORE_SEPARATED_$1_$0_2 = "UNDERSCORE_SEPARATED_$1_$0_2",
    NONUNDERSCORE = "NONUNDERSCORE",
    QUOTED = "QUOTED",
    __ = "__",
    _ = "_",
    $EOF = "$EOF",
}
export type DECLS = DECLS_1 | DECLS_2;
export class DECLS_1 {
    public kind: ASTKinds.DECLS_1 = ASTKinds.DECLS_1;
    public beginpos: PosInfo;
    public head: DECL;
    public tail: DECLS_$0[];
    public endpos: PosInfo;
    public val: Decl[];
    constructor(beginpos: PosInfo, head: DECL, tail: DECLS_$0[], endpos: PosInfo){
        this.beginpos = beginpos;
        this.head = head;
        this.tail = tail;
        this.endpos = endpos;
        this.val = ((): Decl[] => {
        return [...this.head.val, ...this.tail.map(t => t.d.val).flat()];
        })();
    }
}
export class DECLS_2 {
    public kind: ASTKinds.DECLS_2 = ASTKinds.DECLS_2;
    public beginpos: PosInfo;
    public endpos: PosInfo;
    public val: Decl[];
    constructor(beginpos: PosInfo, endpos: PosInfo){
        this.beginpos = beginpos;
        this.endpos = endpos;
        this.val = ((): Decl[] => {
        return [];
        })();
    }
}
export interface DECLS_$0 {
    kind: ASTKinds.DECLS_$0;
    d: DECL;
}
export type DECL = DECL_1 | DECL_2 | DECL_3;
export class DECL_1 {
    public kind: ASTKinds.DECL_1 = ASTKinds.DECL_1;
    public beginpos: PosInfo;
    public name: NAME;
    public v: VALUE;
    public endpos: PosInfo;
    public val: Decl[];
    constructor(beginpos: PosInfo, name: NAME, v: VALUE, endpos: PosInfo){
        this.beginpos = beginpos;
        this.name = name;
        this.v = v;
        this.endpos = endpos;
        this.val = ((): Decl[] => {
        const begin = this.beginpos.overallPos;
      const end = this.endpos.overallPos;
      return [{ contexts: [], name: this.name.val, value: this.v.val, begin, end }];
        })();
    }
}
export class DECL_2 {
    public kind: ASTKinds.DECL_2 = ASTKinds.DECL_2;
    public name: NAME;
    public decl: DECL;
    public val: Decl[];
    constructor(name: NAME, decl: DECL){
        this.name = name;
        this.decl = decl;
        this.val = ((): Decl[] => {
        return this.decl.val.map(d => ({ ...d, contexts: d.contexts.concat(this.name.val) }));
        })();
    }
}
export class DECL_3 {
    public kind: ASTKinds.DECL_3 = ASTKinds.DECL_3;
    public name: NAME;
    public ds: DECLS;
    public val: Decl[];
    constructor(name: NAME, ds: DECLS){
        this.name = name;
        this.ds = ds;
        this.val = ((): Decl[] => {
        return this.ds.val.map(d => ({ ...d, contexts: d.contexts.concat(this.name.val) }));
        })();
    }
}
export class NAME {
    public kind: ASTKinds.NAME = ASTKinds.NAME;
    public head: FRAG;
    public tail: NAME_$0[];
    public val: string[];
    constructor(head: FRAG, tail: NAME_$0[]){
        this.head = head;
        this.tail = tail;
        this.val = ((): string[] => {
        return [this.head, ...this.tail.map(t => t.f)];
        })();
    }
}
export interface NAME_$0 {
    kind: ASTKinds.NAME_$0;
    f: FRAG;
}
export type FRAG = string;
export type VALUE = UNDERSCORE_SEPARATED;
export class UNDERSCORE_SEPARATED {
    public kind: ASTKinds.UNDERSCORE_SEPARATED = ASTKinds.UNDERSCORE_SEPARATED;
    public head: UNDERSCORE_SEPARATED_$0;
    public tail: UNDERSCORE_SEPARATED_$1[];
    public val: string[];
    constructor(head: UNDERSCORE_SEPARATED_$0, tail: UNDERSCORE_SEPARATED_$1[]){
        this.head = head;
        this.tail = tail;
        this.val = ((): string[] => {
        return [this.head.val, ...this.tail.map(t => t.v.val)];
        })();
    }
}
export type UNDERSCORE_SEPARATED_$0 = UNDERSCORE_SEPARATED_$0_1 | UNDERSCORE_SEPARATED_$0_2;
export type UNDERSCORE_SEPARATED_$0_1 = NONUNDERSCORE;
export type UNDERSCORE_SEPARATED_$0_2 = QUOTED;
export interface UNDERSCORE_SEPARATED_$1 {
    kind: ASTKinds.UNDERSCORE_SEPARATED_$1;
    v: UNDERSCORE_SEPARATED_$1_$0;
}
export type UNDERSCORE_SEPARATED_$1_$0 = UNDERSCORE_SEPARATED_$1_$0_1 | UNDERSCORE_SEPARATED_$1_$0_2;
export type UNDERSCORE_SEPARATED_$1_$0_1 = NONUNDERSCORE;
export type UNDERSCORE_SEPARATED_$1_$0_2 = QUOTED;
export class NONUNDERSCORE {
    public kind: ASTKinds.NONUNDERSCORE = ASTKinds.NONUNDERSCORE;
    public v: string;
    public val: string;
    constructor(v: string){
        this.v = v;
        this.val = ((): string => {
        return this.v.replace(/\\_/g, "_");
        })();
    }
}
export class QUOTED {
    public kind: ASTKinds.QUOTED = ASTKinds.QUOTED;
    public v: string;
    public val: string;
    constructor(v: string){
        this.v = v;
        this.val = ((): string => {
        return this.v.replace(/\\\u0027/g, "'");
        })();
    }
}
export type __ = string;
export type _ = string;
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
        this.$scope$DECLS$memo.clear();
        this.$scope$DECLS_$0$memo.clear();
        this.$scope$DECL$memo.clear();
        this.$scope$NAME$memo.clear();
        this.$scope$NAME_$0$memo.clear();
        this.$scope$FRAG$memo.clear();
        this.$scope$VALUE$memo.clear();
        this.$scope$UNDERSCORE_SEPARATED$memo.clear();
        this.$scope$UNDERSCORE_SEPARATED_$0$memo.clear();
        this.$scope$UNDERSCORE_SEPARATED_$1$memo.clear();
        this.$scope$UNDERSCORE_SEPARATED_$1_$0$memo.clear();
        this.$scope$NONUNDERSCORE$memo.clear();
        this.$scope$QUOTED$memo.clear();
        this.$scope$__$memo.clear();
        this.$scope$_$memo.clear();
    }
    protected $scope$DECLS$memo: Map<number, [Nullable<DECLS>, PosInfo]> = new Map();
    protected $scope$DECLS_$0$memo: Map<number, [Nullable<DECLS_$0>, PosInfo]> = new Map();
    protected $scope$DECL$memo: Map<number, [Nullable<DECL>, PosInfo]> = new Map();
    protected $scope$NAME$memo: Map<number, [Nullable<NAME>, PosInfo]> = new Map();
    protected $scope$NAME_$0$memo: Map<number, [Nullable<NAME_$0>, PosInfo]> = new Map();
    protected $scope$FRAG$memo: Map<number, [Nullable<FRAG>, PosInfo]> = new Map();
    protected $scope$VALUE$memo: Map<number, [Nullable<VALUE>, PosInfo]> = new Map();
    protected $scope$UNDERSCORE_SEPARATED$memo: Map<number, [Nullable<UNDERSCORE_SEPARATED>, PosInfo]> = new Map();
    protected $scope$UNDERSCORE_SEPARATED_$0$memo: Map<number, [Nullable<UNDERSCORE_SEPARATED_$0>, PosInfo]> = new Map();
    protected $scope$UNDERSCORE_SEPARATED_$1$memo: Map<number, [Nullable<UNDERSCORE_SEPARATED_$1>, PosInfo]> = new Map();
    protected $scope$UNDERSCORE_SEPARATED_$1_$0$memo: Map<number, [Nullable<UNDERSCORE_SEPARATED_$1_$0>, PosInfo]> = new Map();
    protected $scope$NONUNDERSCORE$memo: Map<number, [Nullable<NONUNDERSCORE>, PosInfo]> = new Map();
    protected $scope$QUOTED$memo: Map<number, [Nullable<QUOTED>, PosInfo]> = new Map();
    protected $scope$__$memo: Map<number, [Nullable<__>, PosInfo]> = new Map();
    protected $scope$_$memo: Map<number, [Nullable<_>, PosInfo]> = new Map();
    public matchDECLS($$dpth: number, $$cr?: ErrorTracker): Nullable<DECLS> {
        return this.memoise(
            () => {
                return this.choice<DECLS>([
                    () => this.matchDECLS_1($$dpth + 1, $$cr),
                    () => this.matchDECLS_2($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$DECLS$memo,
        );
    }
    public matchDECLS_1($$dpth: number, $$cr?: ErrorTracker): Nullable<DECLS_1> {
        return this.run<DECLS_1>($$dpth,
            () => {
                let $scope$beginpos: Nullable<PosInfo>;
                let $scope$head: Nullable<DECL>;
                let $scope$tail: Nullable<DECLS_$0[]>;
                let $scope$endpos: Nullable<PosInfo>;
                let $$res: Nullable<DECLS_1> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$beginpos = this.mark()) !== null
                    && ($scope$head = this.matchDECL($$dpth + 1, $$cr)) !== null
                    && ($scope$tail = this.loop<DECLS_$0>(() => this.matchDECLS_$0($$dpth + 1, $$cr), 0, -1)) !== null
                    && ($scope$endpos = this.mark()) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.match$EOF($$cr) !== null
                ) {
                    $$res = new DECLS_1($scope$beginpos, $scope$head, $scope$tail, $scope$endpos);
                }
                return $$res;
            });
    }
    public matchDECLS_2($$dpth: number, $$cr?: ErrorTracker): Nullable<DECLS_2> {
        return this.run<DECLS_2>($$dpth,
            () => {
                let $scope$beginpos: Nullable<PosInfo>;
                let $scope$endpos: Nullable<PosInfo>;
                let $$res: Nullable<DECLS_2> = null;
                if (true
                    && ($scope$beginpos = this.mark()) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$endpos = this.mark()) !== null
                    && this.match$EOF($$cr) !== null
                ) {
                    $$res = new DECLS_2($scope$beginpos, $scope$endpos);
                }
                return $$res;
            });
    }
    public matchDECLS_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<DECLS_$0> {
        return this.memoise(
            () => {
                return this.run<DECLS_$0>($$dpth,
                    () => {
                        let $scope$d: Nullable<DECL>;
                        let $$res: Nullable<DECLS_$0> = null;
                        if (true
                            && this.match__($$dpth + 1, $$cr) !== null
                            && ($scope$d = this.matchDECL($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.DECLS_$0, d: $scope$d};
                        }
                        return $$res;
                    });
            },
            this.$scope$DECLS_$0$memo,
        );
    }
    public matchDECL($$dpth: number, $$cr?: ErrorTracker): Nullable<DECL> {
        return this.memoise(
            () => {
                return this.choice<DECL>([
                    () => this.matchDECL_1($$dpth + 1, $$cr),
                    () => this.matchDECL_2($$dpth + 1, $$cr),
                    () => this.matchDECL_3($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$DECL$memo,
        );
    }
    public matchDECL_1($$dpth: number, $$cr?: ErrorTracker): Nullable<DECL_1> {
        return this.run<DECL_1>($$dpth,
            () => {
                let $scope$beginpos: Nullable<PosInfo>;
                let $scope$name: Nullable<NAME>;
                let $scope$v: Nullable<VALUE>;
                let $scope$endpos: Nullable<PosInfo>;
                let $$res: Nullable<DECL_1> = null;
                if (true
                    && ($scope$beginpos = this.mark()) !== null
                    && ($scope$name = this.matchNAME($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?::)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$v = this.matchVALUE($$dpth + 1, $$cr)) !== null
                    && ($scope$endpos = this.mark()) !== null
                ) {
                    $$res = new DECL_1($scope$beginpos, $scope$name, $scope$v, $scope$endpos);
                }
                return $$res;
            });
    }
    public matchDECL_2($$dpth: number, $$cr?: ErrorTracker): Nullable<DECL_2> {
        return this.run<DECL_2>($$dpth,
            () => {
                let $scope$name: Nullable<NAME>;
                let $scope$decl: Nullable<DECL>;
                let $$res: Nullable<DECL_2> = null;
                if (true
                    && ($scope$name = this.matchNAME($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:.)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$decl = this.matchDECL($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new DECL_2($scope$name, $scope$decl);
                }
                return $$res;
            });
    }
    public matchDECL_3($$dpth: number, $$cr?: ErrorTracker): Nullable<DECL_3> {
        return this.run<DECL_3>($$dpth,
            () => {
                let $scope$name: Nullable<NAME>;
                let $scope$ds: Nullable<DECLS>;
                let $$res: Nullable<DECL_3> = null;
                if (true
                    && ($scope$name = this.matchNAME($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:.\()`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$ds = this.matchDECLS($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\))`, "", $$dpth + 1, $$cr) !== null
                ) {
                    $$res = new DECL_3($scope$name, $scope$ds);
                }
                return $$res;
            });
    }
    public matchNAME($$dpth: number, $$cr?: ErrorTracker): Nullable<NAME> {
        return this.memoise(
            () => {
                return this.run<NAME>($$dpth,
                    () => {
                        let $scope$head: Nullable<FRAG>;
                        let $scope$tail: Nullable<NAME_$0[]>;
                        let $$res: Nullable<NAME> = null;
                        if (true
                            && ($scope$head = this.matchFRAG($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<NAME_$0>(() => this.matchNAME_$0($$dpth + 1, $$cr), 0, -1)) !== null
                        ) {
                            $$res = new NAME($scope$head, $scope$tail);
                        }
                        return $$res;
                    });
            },
            this.$scope$NAME$memo,
        );
    }
    public matchNAME_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<NAME_$0> {
        return this.memoise(
            () => {
                return this.run<NAME_$0>($$dpth,
                    () => {
                        let $scope$f: Nullable<FRAG>;
                        let $$res: Nullable<NAME_$0> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:-)`, "", $$dpth + 1, $$cr) !== null
                            && ($scope$f = this.matchFRAG($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.NAME_$0, f: $scope$f};
                        }
                        return $$res;
                    });
            },
            this.$scope$NAME_$0$memo,
        );
    }
    public matchFRAG($$dpth: number, $$cr?: ErrorTracker): Nullable<FRAG> {
        return this.memoise(
            () => {
                return this.regexAccept(String.raw`(?:[^-\s:\.]+)`, "", $$dpth + 1, $$cr);
            },
            this.$scope$FRAG$memo,
        );
    }
    public matchVALUE($$dpth: number, $$cr?: ErrorTracker): Nullable<VALUE> {
        return this.memoise(
            () => {
                return this.matchUNDERSCORE_SEPARATED($$dpth + 1, $$cr);
            },
            this.$scope$VALUE$memo,
        );
    }
    public matchUNDERSCORE_SEPARATED($$dpth: number, $$cr?: ErrorTracker): Nullable<UNDERSCORE_SEPARATED> {
        return this.memoise(
            () => {
                return this.run<UNDERSCORE_SEPARATED>($$dpth,
                    () => {
                        let $scope$head: Nullable<UNDERSCORE_SEPARATED_$0>;
                        let $scope$tail: Nullable<UNDERSCORE_SEPARATED_$1[]>;
                        let $$res: Nullable<UNDERSCORE_SEPARATED> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:_*)`, "", $$dpth + 1, $$cr) !== null
                            && ($scope$head = this.matchUNDERSCORE_SEPARATED_$0($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<UNDERSCORE_SEPARATED_$1>(() => this.matchUNDERSCORE_SEPARATED_$1($$dpth + 1, $$cr), 0, -1)) !== null
                            && this.regexAccept(String.raw`(?:_*)`, "", $$dpth + 1, $$cr) !== null
                        ) {
                            $$res = new UNDERSCORE_SEPARATED($scope$head, $scope$tail);
                        }
                        return $$res;
                    });
            },
            this.$scope$UNDERSCORE_SEPARATED$memo,
        );
    }
    public matchUNDERSCORE_SEPARATED_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<UNDERSCORE_SEPARATED_$0> {
        return this.memoise(
            () => {
                return this.choice<UNDERSCORE_SEPARATED_$0>([
                    () => this.matchUNDERSCORE_SEPARATED_$0_1($$dpth + 1, $$cr),
                    () => this.matchUNDERSCORE_SEPARATED_$0_2($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$UNDERSCORE_SEPARATED_$0$memo,
        );
    }
    public matchUNDERSCORE_SEPARATED_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<UNDERSCORE_SEPARATED_$0_1> {
        return this.matchNONUNDERSCORE($$dpth + 1, $$cr);
    }
    public matchUNDERSCORE_SEPARATED_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<UNDERSCORE_SEPARATED_$0_2> {
        return this.matchQUOTED($$dpth + 1, $$cr);
    }
    public matchUNDERSCORE_SEPARATED_$1($$dpth: number, $$cr?: ErrorTracker): Nullable<UNDERSCORE_SEPARATED_$1> {
        return this.memoise(
            () => {
                return this.run<UNDERSCORE_SEPARATED_$1>($$dpth,
                    () => {
                        let $scope$v: Nullable<UNDERSCORE_SEPARATED_$1_$0>;
                        let $$res: Nullable<UNDERSCORE_SEPARATED_$1> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:_+)`, "", $$dpth + 1, $$cr) !== null
                            && ($scope$v = this.matchUNDERSCORE_SEPARATED_$1_$0($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.UNDERSCORE_SEPARATED_$1, v: $scope$v};
                        }
                        return $$res;
                    });
            },
            this.$scope$UNDERSCORE_SEPARATED_$1$memo,
        );
    }
    public matchUNDERSCORE_SEPARATED_$1_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<UNDERSCORE_SEPARATED_$1_$0> {
        return this.memoise(
            () => {
                return this.choice<UNDERSCORE_SEPARATED_$1_$0>([
                    () => this.matchUNDERSCORE_SEPARATED_$1_$0_1($$dpth + 1, $$cr),
                    () => this.matchUNDERSCORE_SEPARATED_$1_$0_2($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$UNDERSCORE_SEPARATED_$1_$0$memo,
        );
    }
    public matchUNDERSCORE_SEPARATED_$1_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<UNDERSCORE_SEPARATED_$1_$0_1> {
        return this.matchNONUNDERSCORE($$dpth + 1, $$cr);
    }
    public matchUNDERSCORE_SEPARATED_$1_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<UNDERSCORE_SEPARATED_$1_$0_2> {
        return this.matchQUOTED($$dpth + 1, $$cr);
    }
    public matchNONUNDERSCORE($$dpth: number, $$cr?: ErrorTracker): Nullable<NONUNDERSCORE> {
        return this.memoise(
            () => {
                return this.run<NONUNDERSCORE>($$dpth,
                    () => {
                        let $scope$v: Nullable<string>;
                        let $$res: Nullable<NONUNDERSCORE> = null;
                        if (true
                            && ($scope$v = this.regexAccept(String.raw`(?:([^\s_]|\\_)+)`, "", $$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = new NONUNDERSCORE($scope$v);
                        }
                        return $$res;
                    });
            },
            this.$scope$NONUNDERSCORE$memo,
        );
    }
    public matchQUOTED($$dpth: number, $$cr?: ErrorTracker): Nullable<QUOTED> {
        return this.memoise(
            () => {
                return this.run<QUOTED>($$dpth,
                    () => {
                        let $scope$v: Nullable<string>;
                        let $$res: Nullable<QUOTED> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:\')`, "", $$dpth + 1, $$cr) !== null
                            && ($scope$v = this.regexAccept(String.raw`(?:([^\']|\\\')*)`, "", $$dpth + 1, $$cr)) !== null
                            && this.regexAccept(String.raw`(?:\')`, "", $$dpth + 1, $$cr) !== null
                        ) {
                            $$res = new QUOTED($scope$v);
                        }
                        return $$res;
                    });
            },
            this.$scope$QUOTED$memo,
        );
    }
    public match__($$dpth: number, $$cr?: ErrorTracker): Nullable<__> {
        return this.memoise(
            () => {
                return this.regexAccept(String.raw`(?:[ \t\n\r]+)`, "", $$dpth + 1, $$cr);
            },
            this.$scope$__$memo,
        );
    }
    public match_($$dpth: number, $$cr?: ErrorTracker): Nullable<_> {
        return this.memoise(
            () => {
                return this.regexAccept(String.raw`(?:[ \t\n\r]*)`, "", $$dpth + 1, $$cr);
            },
            this.$scope$_$memo,
        );
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchDECLS(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchDECLS(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchDECLS(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    // @ts-ignore: loopPlus may not be called
    private loopPlus<T>(func: $$RuleType<T>): Nullable<[T, ...T[]]> {
        return this.loop(func, 1, -1) as Nullable<[T, ...T[]]>;
    }
    private loop<T>(func: $$RuleType<T>, lb: number, ub: number): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        while (ub === -1 || res.length < ub) {
            const preMrk = this.mark();
            const t = func();
            if (t === null || this.pos.overallPos === preMrk.overallPos) {
                break;
            }
            res.push(t);
        }
        if (res.length >= lb) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    // @ts-ignore: choice may not be called
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, mods: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y" + mods);
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    // @ts-ignore: noConsume may not be called
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    // @ts-ignore: negate may not be called
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    // @ts-ignore: Memoise may not be used
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {
        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;
        if(et)
            et.record(this.mark(), res, { kind: "EOF", negated: this.negating });
        return res;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<DECLS>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}